package lang.ast;
import beaver.*;
import java.util.ArrayList;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.Stack;
import java.util.zip.DeflaterOutputStream;

// This is a parser generated by NeoBeaver.
public class LangParser extends beaver.Parser {
  
    static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
    // Disable syntax error recovery
    protected void recoverFromError(Symbol token, TokenStream in) {
        throw new SyntaxError("Cannot recover from the syntax error");
    }

  public static class Terminals {
    public static final short EOF = 0;
    public static final short ID = 1;
    public static final short SUB = 2;
    public static final short RIGHTPAR = 3;
    public static final short SEPERATOR = 4;
    public static final short END = 5;
    public static final short INT = 6;
    public static final short LEFTPAR = 7;
    public static final short RIGHTBRAK = 8;
    public static final short ADD = 9;
    public static final short IF = 10;
    public static final short WHILE = 11;
    public static final short RETURN = 12;
    public static final short NUMERAL = 13;
    public static final short NOTEQUAL = 14;
    public static final short LESSOREQUALTHAN = 15;
    public static final short GREATERTHAN = 16;
    public static final short EQUAL = 17;
    public static final short GREATEROREQUALTHAN = 18;
    public static final short LESSTHAN = 19;
    public static final short MOD = 20;
    public static final short MUL = 21;
    public static final short DIV = 22;
    public static final short ASSIGN = 23;
    public static final short LEFTBRAK = 24;
    public static final short ELSE = 25;

    public static final String[] NAMES = {
        "EOF",
        "ID",
        "SUB",
        "RIGHTPAR",
        "SEPERATOR",
        "END",
        "INT",
        "LEFTPAR",
        "RIGHTBRAK",
        "ADD",
        "IF",
        "WHILE",
        "RETURN",
        "NUMERAL",
        "NOTEQUAL",
        "LESSOREQUALTHAN",
        "GREATERTHAN",
        "EQUAL",
        "GREATEROREQUALTHAN",
        "LESSTHAN",
        "MOD",
        "MUL",
        "DIV",
        "ASSIGN",
        "LEFTBRAK",
        "ELSE",
    };
  }

  private final Action[] actions = {
    new Action() { // [0] function_list =  functionDecl
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final FunctionDecl a = (FunctionDecl) _symbols[offset + 1].value;
        return new List().add(a) ;
      }
    },
    new Action() { // [1] program =  function_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return new Program(a);
      }
    },
    new Action() { // [2] argument = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [3] id_decl =  INT ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final Symbol id = _symbols[offset + 2];
        return new IdDecl(id);
      }
    },
    new Action() { // [4] function_list =  function_list functionDecl
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final FunctionDecl b = (FunctionDecl) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [5] GOAL =  program EOF
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Program program = (Program) _symbols[offset + 1].value;
        final Symbol sym2 = _symbols[offset + 2];
        return program;
      }
    },
    new Action() { // [6] argument_list =  id_decl
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl a = (IdDecl) _symbols[offset + 1].value;
        return new List().add(a);
      }
    },
    new Action() { // [7] argument =  argument_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return a;
      }
    },
    new Action() { // [8] opt_stmt_list = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new Block();
      }
    },
    new Action() { // [9] argument_list =  argument_list SEPERATOR id_decl
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Symbol SEPERATOR = _symbols[offset + 2];
        final IdDecl b = (IdDecl) _symbols[offset + 3].value;
        return a.add(b);
      }
    },
    Action.RETURN, // [10] stmt =  declare (default action: return symbol 1)
    new Action() { // [11] id_use =  ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        return new IdUse(id);
      }
    },
    new Action() { // [12] stmt_list =  stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Stmt a = (Stmt) _symbols[offset + 1].value;
        return new List().add(a) ;
      }
    },
    new Action() { // [13] opt_stmt_list =  stmt_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return  new Block(a);
      }
    },
    new Action() { // [14] opt_expr_list = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [15] function_call_stmt =  function_call END
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final FunctionCall a = (FunctionCall) _symbols[offset + 1].value;
        final Symbol END = _symbols[offset + 2];
        return new FunctionCallStmt(a);
      }
    },
    new Action() { // [16] stmt_list =  stmt_list stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Stmt b = (Stmt) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [17] declare =  id_decl END
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl id = (IdDecl) _symbols[offset + 1].value;
        final Symbol END = _symbols[offset + 2];
        return new DeclareStmt(id, new Opt());
      }
    },
    Action.RETURN, // [18] expr =  term (default action: return symbol 1)
    Action.RETURN, // [19] factor =  num (default action: return symbol 1)
    Action.RETURN, // [20] num =  numeral (default action: return symbol 1)
    new Action() { // [21] numeral =  NUMERAL
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol num = _symbols[offset + 1];
        return new Numeral(num);
      }
    },
    Action.RETURN, // [22] term =  factor (default action: return symbol 1)
    new Action() { // [23] functionDecl =  id_decl LEFTPAR argument RIGHTPAR LEFTBRAK opt_stmt_list RIGHTBRAK
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl id = (IdDecl) _symbols[offset + 1].value;
        final Symbol LEFTPAR = _symbols[offset + 2];
        final List b = (List) _symbols[offset + 3].value;
        final Symbol RIGHTPAR = _symbols[offset + 4];
        final Symbol LEFTBRAK = _symbols[offset + 5];
        final Block a = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRAK = _symbols[offset + 7];
        return new FunctionDecl(id,b,a);
      }
    },
    new Action() { // [24] expr_list =  expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        return new List().add(a);
      }
    },
    new Action() { // [25] opt_expr_list =  expr_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return a;
      }
    },
    new Action() { // [26] returnStmt =  RETURN expr END
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol RETURN = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        final Symbol END = _symbols[offset + 3];
        return new ReturnStmt(a);
      }
    },
    new Action() { // [27] invNum =  SUB num
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol SUB = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        return new InvNumeral(a);
      }
    },
    new Action() { // [28] function_call =  id_use LEFTPAR opt_expr_list RIGHTPAR
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse a = (IdUse) _symbols[offset + 1].value;
        final Symbol LEFTPAR = _symbols[offset + 2];
        final List b = (List) _symbols[offset + 3].value;
        final Symbol RIGHTPAR = _symbols[offset + 4];
        return new FunctionCall(a,b);
      }
    },
    new Action() { // [29] assignment =  id_use ASSIGN expr END
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse id = (IdUse) _symbols[offset + 1].value;
        final Symbol ASSIGN = _symbols[offset + 2];
        final Expr n = (Expr) _symbols[offset + 3].value;
        final Symbol END = _symbols[offset + 4];
        return new AssignStmt(id, n);
      }
    },
    new Action() { // [30] declare =  id_decl ASSIGN expr END
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl id = (IdDecl) _symbols[offset + 1].value;
        final Symbol ASSIGN = _symbols[offset + 2];
        final Expr n = (Expr) _symbols[offset + 3].value;
        final Symbol END = _symbols[offset + 4];
        return new DeclareStmt(id, new Opt(n));
      }
    },
    new Action() { // [31] term =  term ADD factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol ADD = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Add(a, b);
      }
    },
    new Action() { // [32] term =  term SUB factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol SUB = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Sub(a, b);
      }
    },
    new Action() { // [33] expr =  term GREATEROREQUALTHAN term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol GREATEROREQUALTHAN = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new GreaterOrEqual(a,b);
      }
    },
    new Action() { // [34] expr =  term LESSOREQUALTHAN term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol LESSOREQUALTHAN = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new LessOrEqual(a,b);
      }
    },
    new Action() { // [35] expr =  term GREATERTHAN term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol GREATERTHAN = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Greater(a,b);
      }
    },
    new Action() { // [36] expr =  term NOTEQUAL term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol NOTEQUAL = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new NotEqual(a,b);
      }
    },
    new Action() { // [37] expr =  term EQUAL term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol EQUAL = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Equal(a,b);
      }
    },
    new Action() { // [38] expr =  term LESSTHAN term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol LESSTHAN = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Less(a,b);
      }
    },
    new Action() { // [39] num =  LEFTPAR expr RIGHTPAR
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol LEFTPAR = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        final Symbol RIGHTPAR = _symbols[offset + 3];
        return a;
      }
    },
    new Action() { // [40] factor =  factor DIV num
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol DIV = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Div(a, b);
      }
    },
    new Action() { // [41] factor =  factor MOD num
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol MOD = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Mod(a, b);
      }
    },
    new Action() { // [42] factor =  factor MUL num
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol MUL = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Mul(a, b);
      }
    },
    new Action() { // [43] expr_list =  expr_list SEPERATOR expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Symbol SEPERATOR = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return a.add(b);
      }
    },
    new Action() { // [44] if_else_stmt =  ifStmt ELSE LEFTBRAK opt_stmt_list RIGHTBRAK
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IfStmt a = (IfStmt) _symbols[offset + 1].value;
        final Symbol ELSE = _symbols[offset + 2];
        final Symbol LEFTBRAK = _symbols[offset + 3];
        final Block b = (Block) _symbols[offset + 4].value;
        final Symbol RIGHTBRAK = _symbols[offset + 5];
        return new IfElseStmt(a,b);
      }
    },
    new Action() { // [45] whileStmt =  WHILE LEFTPAR expr RIGHTPAR LEFTBRAK opt_stmt_list RIGHTBRAK
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol WHILE = _symbols[offset + 1];
        final Symbol LEFTPAR = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPAR = _symbols[offset + 4];
        final Symbol LEFTBRAK = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRAK = _symbols[offset + 7];
        return new WhileStmt(a,b);
      }
    },
    new Action() { // [46] ifStmt =  IF LEFTPAR expr RIGHTPAR LEFTBRAK opt_stmt_list RIGHTBRAK
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol IF = _symbols[offset + 1];
        final Symbol LEFTPAR = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPAR = _symbols[offset + 4];
        final Symbol LEFTBRAK = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRAK = _symbols[offset + 7];
        return new IfStmt(a,b);
      }
    },
  };

  static final ParsingTables PARSING_TABLES = new ParsingTables(
    "U9pjcbkC54KKXl#PtPdP2tUvBBl0NjZbkhk0kok2A22AeeAAWXSGyGB8aqQZyK63qMYYYT7" +
    "49n#CcfXeJ7pomMZYcubF9e2e8CfLHK5GH10GBF#gcfwkgUcfdQwL5Wrryj5Lf#hlKwUwgM" +
    "wQ0UfUGZNI64xgSGdwi0GpC1EwL263Ma1inXYCGXQ3C5Zvcv3318p0QBHWB9en4WreGwFIT" +
    "obzBpevhXj1eLw8Ggk9TQcVREXjxQLgP4s9$pBCmTmIx#NAiqPwn5#gVhVghIuPUKM9Ppwf" +
    "A$5UPtXMgFfQLPSheOeugrQYkcGbRYvQYPKmYZWZJHwBujrMrBfTzOUQFulgviWxYbft6kD" +
    "E5$MiAcgjBidr7dLzJebJmVKXTbRhc1N2xFFZXfICMw$6EOeuYQ7k4H5bM6m5U6NYbujCjV" +
    "Y3n$4OXrQNH9mG9#A64SVDcaQQK$ExDbdJ5FjD6qWSJEndykqHSpjcrZJIdEVfw2TEHF5Qj" +
    "xYQIR3lWzzGmNs0gVrE7vXYjQTLeB7BzFYIHDRDKyErlhXGxp7yinoQsSupbeqZZiQCup4t" +
    "yQjPqqXppcsUipSwpYzcJIFDAVB9vuXPqqZxf#DuQHQAmzBohGK5$zLOXAkm65VY6biYVjO" +
    "Mj6n$Q8ReMiSSoXHnI5lGilsX3L1pK5lGilsX6PDBwFg8dxG5BTkl#cx0KbnlQC8C9vxJTV" +
    "inkkugue0uKDb8eooBhO3u0JV65jqKFuxF#mwMUyIvnKDpguScgNtdWiPlF$ZUh6caEQ90V" +
    "ASjQDd#q0pHNQupbYddyxhjrnQqR7ze0uoppwnff9LNiDphx8sEizUiQQGvHVV5ZuFxuql4" +
    "7cr1o$QhFlkPjLjRqBBzgi$IyDrbbxHyQq55arielfKMK$EDj9YQdT9YQhwM5bEpGreSZTY" +
    "kBMZP$j0CpLVQWfRj3ytGVAajQDd#q0pD5zg2bkqFpT1i4zigoRje3JutQnffJf7Fizv7iy" +
    "7P6rqUY2yHMysQHffJiyMiQQGvncUPhRP6D37tyPWWL44Nkj75uopLqylTjaVvMv7ZcsixE" +
    "Z09a$al$gdyL$vqT8PwDAE5uzf4lgWU55gjZ6dh8xL8bVhLLxrIR#Y1KSywHnOY5McYneNr" +
    "HlbjLysjgamcrae8ew2ATrc6nrnnl9BeOmmDZ7hMhGirhd5bSkNSWkj38hBIrz68qafDv3X" +
    "N2UDKNj0GLo7NoaEJCjMe8NMeno2dnYSVdpZfyEuXjGN$40p5C0p72Evb8p4AeyExnojEhf" +
    "#vZudm#SJ9kED4QdpYnDHWxBdBnrwx$jOwyXm#cWJMpL#3TA5kv8R13asDwupbuyWzErOSd" +
    "xdvh87F$fRKMYSMnqDJs1DLAt9FzD7eVTJG#EnLFd6Iqfn7rwTyFlqzvmOOf#YzgdmEHVdu" +
    "FEkhuYeyuoJrFFM9uxK67fgaxkiBckIU9Jv$j$zlzqvYUtoXLldryNeNyuZZyuxae$cNdzi" +
    "#SxkWEK$UgxpsgeI#7oIbyTaFajf3OdyB0B3nAQXtnTFGNujxoTBy5zsdoQlaVRAP70HIAT" +
    "94#iXSifuyIruZ7vAjv32GvhXqAvbDLf07oVFaTV81sKAE0bNrf8FC9yl98#H5yZPvb#man" +
    "u7geMGgMKHMayS8nrLpJFKdP1Sv1MIOGwQJB2PhoHFa5V8U#PJi9cU1BCTbPv0bP1tPH9Xh" +
    "bhbcFoC7W1npo37N77FDBICRo3E4kUQOGuvhaZi4r6H80vb3vf6Lv3do1lc8R2D7WDeQqaO" +
    "uffPZQXyYBv2toCTa1pa6r0qcBOJhMxUAF9g$HdisyOy0bdtvutxJRyEobvnqZGbWc0P7Nt" +
    "t#A7yfrsVrBSWVUQsnnZ4N#GkEZHNCuqch$J1vcRn9tY5SB$2wGtxxtswDvJLLlxzuFD$UN" +
    "KdkbSBpoL#Rd8dmRtJztyL$jin0Dz#sUedy$#XMFWMwoIpIetmfzOl67kxq7QmtaKxbIr4f" +
    "xvKqsscqapRwciauCfwqa2xaC5EDJM4App61unhvb9b4saaBVPAsCemZpGOpoJHaC97ddKp" +
    "w$WPkEShE");

  public LangParser() {
    super(PARSING_TABLES);
  }

  protected Symbol invokeReduceAction(int rule_num, int offset) {
    return actions[rule_num].reduce(_symbols, offset);
  }
}
