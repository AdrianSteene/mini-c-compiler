package lang.ast;
import beaver.*;
import java.util.ArrayList;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.Stack;
import java.util.zip.DeflaterOutputStream;

// This is a parser generated by NeoBeaver.
public class LangParser extends beaver.Parser {
  
    static public class SyntaxError extends RuntimeException { public SyntaxError(String msg) {super(msg);}}
    // Disable syntax error recovery
    protected void recoverFromError(Symbol token, TokenStream in) {
        throw new SyntaxError("Cannot recover from the syntax error");
    }

  public static class Terminals {
    public static final short EOF = 0;
    public static final short ID = 1;
    public static final short SUB = 2;
    public static final short RIGHTPAR = 3;
    public static final short SEPERATOR = 4;
    public static final short INT = 5;
    public static final short END = 6;
    public static final short LEFTPAR = 7;
    public static final short RIGHTBRAK = 8;
    public static final short ADD = 9;
    public static final short WHILE = 10;
    public static final short RETURN = 11;
    public static final short IF = 12;
    public static final short NUMERAL = 13;
    public static final short LESSOREQUALTHAN = 14;
    public static final short EQUAL = 15;
    public static final short LESSTHAN = 16;
    public static final short GREATEROREQUALTHAN = 17;
    public static final short GREATERTHAN = 18;
    public static final short NOTEQUAL = 19;
    public static final short DIV = 20;
    public static final short MUL = 21;
    public static final short MOD = 22;
    public static final short ASSIGN = 23;
    public static final short LEFTBRAK = 24;
    public static final short ELSE = 25;

    public static final String[] NAMES = {
        "EOF",
        "ID",
        "SUB",
        "RIGHTPAR",
        "SEPERATOR",
        "INT",
        "END",
        "LEFTPAR",
        "RIGHTBRAK",
        "ADD",
        "WHILE",
        "RETURN",
        "IF",
        "NUMERAL",
        "LESSOREQUALTHAN",
        "EQUAL",
        "LESSTHAN",
        "GREATEROREQUALTHAN",
        "GREATERTHAN",
        "NOTEQUAL",
        "DIV",
        "MUL",
        "MOD",
        "ASSIGN",
        "LEFTBRAK",
        "ELSE",
    };
  }

  private final Action[] actions = {
    new Action() { // [0] function_list =  functionDecl
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final FunctionDecl a = (FunctionDecl) _symbols[offset + 1].value;
        return new List().add(a) ;
      }
    },
    new Action() { // [1] program =  function_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return new Program(a);
      }
    },
    new Action() { // [2] GOAL =  program EOF
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Program program = (Program) _symbols[offset + 1].value;
        final Symbol sym2 = _symbols[offset + 2];
        return program;
      }
    },
    new Action() { // [3] id_decl =  INT ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol INT = _symbols[offset + 1];
        final Symbol id = _symbols[offset + 2];
        return new IdDecl(id);
      }
    },
    new Action() { // [4] argument = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [5] function_list =  function_list functionDecl
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final FunctionDecl b = (FunctionDecl) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    new Action() { // [6] argument =  argument_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return a;
      }
    },
    new Action() { // [7] argument_list =  id_decl
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl a = (IdDecl) _symbols[offset + 1].value;
        return new List().add(a);
      }
    },
    new Action() { // [8] opt_stmt_list = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new Block();
      }
    },
    new Action() { // [9] argument_list =  argument_list SEPERATOR id_decl
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Symbol SEPERATOR = _symbols[offset + 2];
        final IdDecl b = (IdDecl) _symbols[offset + 3].value;
        return a.add(b);
      }
    },
    Action.RETURN, // [10] stmt =  assignment (default action: return symbol 1)
    new Action() { // [11] id_use =  ID
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol id = _symbols[offset + 1];
        return new IdUse(id);
      }
    },
    new Action() { // [12] stmt_list =  stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Stmt a = (Stmt) _symbols[offset + 1].value;
        return new List().add(a) ;
      }
    },
    new Action() { // [13] opt_stmt_list =  stmt_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return  new Block(a);
      }
    },
    new Action() { // [14] declare =  id_decl END
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl id = (IdDecl) _symbols[offset + 1].value;
        final Symbol END = _symbols[offset + 2];
        return new DeclareStmt(id, new Opt());
      }
    },
    new Action() { // [15] opt_expr_list = 
      public Symbol reduce(Symbol[] _symbols, int offset) {
        return new List();
      }
    },
    new Action() { // [16] functionDecl =  id_decl LEFTPAR argument RIGHTPAR LEFTBRAK opt_stmt_list RIGHTBRAK
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl id = (IdDecl) _symbols[offset + 1].value;
        final Symbol LEFTPAR = _symbols[offset + 2];
        final List b = (List) _symbols[offset + 3].value;
        final Symbol RIGHTPAR = _symbols[offset + 4];
        final Symbol LEFTBRAK = _symbols[offset + 5];
        final Block a = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRAK = _symbols[offset + 7];
        return new FunctionDecl(id,b,a);
      }
    },
    new Action() { // [17] stmt_list =  stmt_list stmt
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Stmt b = (Stmt) _symbols[offset + 2].value;
        return a.add(b);
      }
    },
    Action.RETURN, // [18] num =  numeral (default action: return symbol 1)
    Action.RETURN, // [19] term =  factor (default action: return symbol 1)
    Action.RETURN, // [20] expr =  term (default action: return symbol 1)
    new Action() { // [21] numeral =  NUMERAL
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol num = _symbols[offset + 1];
        return new Numeral(num);
      }
    },
    Action.RETURN, // [22] factor =  num (default action: return symbol 1)
    new Action() { // [23] function_call_stmt =  function_call END
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final FunctionCall a = (FunctionCall) _symbols[offset + 1].value;
        final Symbol END = _symbols[offset + 2];
        return new FunctionCallStmt(a);
      }
    },
    new Action() { // [24] opt_expr_list =  expr_list
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        return a;
      }
    },
    new Action() { // [25] expr_list =  expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        return new List().add(a);
      }
    },
    new Action() { // [26] returnStmt =  RETURN expr END
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol RETURN = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        final Symbol END = _symbols[offset + 3];
        return new ReturnStmt(a);
      }
    },
    new Action() { // [27] invNum =  SUB num
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol SUB = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        return new InvNumeral(a);
      }
    },
    new Action() { // [28] declare =  id_decl ASSIGN expr END
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdDecl id = (IdDecl) _symbols[offset + 1].value;
        final Symbol ASSIGN = _symbols[offset + 2];
        final Expr n = (Expr) _symbols[offset + 3].value;
        final Symbol END = _symbols[offset + 4];
        return new DeclareStmt(id, new Opt(n));
      }
    },
    new Action() { // [29] assignment =  id_use ASSIGN expr END
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse id = (IdUse) _symbols[offset + 1].value;
        final Symbol ASSIGN = _symbols[offset + 2];
        final Expr n = (Expr) _symbols[offset + 3].value;
        final Symbol END = _symbols[offset + 4];
        return new AssignStmt(id, n);
      }
    },
    new Action() { // [30] function_call =  id_use LEFTPAR opt_expr_list RIGHTPAR
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IdUse a = (IdUse) _symbols[offset + 1].value;
        final Symbol LEFTPAR = _symbols[offset + 2];
        final List b = (List) _symbols[offset + 3].value;
        final Symbol RIGHTPAR = _symbols[offset + 4];
        return new FunctionCall(a,b);
      }
    },
    new Action() { // [31] factor =  factor DIV num
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol DIV = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Div(a, b);
      }
    },
    new Action() { // [32] factor =  factor MOD num
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol MOD = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Mod(a, b);
      }
    },
    new Action() { // [33] factor =  factor MUL num
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol MUL = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Mul(a, b);
      }
    },
    new Action() { // [34] expr =  term LESSOREQUALTHAN term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol LESSOREQUALTHAN = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new LessOrEqual(a,b);
      }
    },
    new Action() { // [35] expr =  term EQUAL term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol EQUAL = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Equal(a,b);
      }
    },
    new Action() { // [36] term =  term ADD factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol ADD = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Add(a, b);
      }
    },
    new Action() { // [37] expr =  term GREATERTHAN term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol GREATERTHAN = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Greater(a,b);
      }
    },
    new Action() { // [38] expr =  term GREATEROREQUALTHAN term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol GREATEROREQUALTHAN = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new GreaterOrEqual(a,b);
      }
    },
    new Action() { // [39] expr =  term LESSTHAN term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol LESSTHAN = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Less(a,b);
      }
    },
    new Action() { // [40] term =  term SUB factor
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol SUB = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new Sub(a, b);
      }
    },
    new Action() { // [41] expr =  term NOTEQUAL term
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Expr a = (Expr) _symbols[offset + 1].value;
        final Symbol NOTEQUAL = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return new NotEqual(a,b);
      }
    },
    new Action() { // [42] num =  LEFTPAR expr RIGHTPAR
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol LEFTPAR = _symbols[offset + 1];
        final Expr a = (Expr) _symbols[offset + 2].value;
        final Symbol RIGHTPAR = _symbols[offset + 3];
        return a;
      }
    },
    new Action() { // [43] expr_list =  expr_list SEPERATOR expr
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final List a = (List) _symbols[offset + 1].value;
        final Symbol SEPERATOR = _symbols[offset + 2];
        final Expr b = (Expr) _symbols[offset + 3].value;
        return a.add(b);
      }
    },
    new Action() { // [44] if_else_stmt =  ifStmt ELSE LEFTBRAK opt_stmt_list RIGHTBRAK
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final IfStmt a = (IfStmt) _symbols[offset + 1].value;
        final Symbol ELSE = _symbols[offset + 2];
        final Symbol LEFTBRAK = _symbols[offset + 3];
        final Block b = (Block) _symbols[offset + 4].value;
        final Symbol RIGHTBRAK = _symbols[offset + 5];
        return new IfElseStmt(a,b);
      }
    },
    new Action() { // [45] whileStmt =  WHILE LEFTPAR expr RIGHTPAR LEFTBRAK opt_stmt_list RIGHTBRAK
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol WHILE = _symbols[offset + 1];
        final Symbol LEFTPAR = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPAR = _symbols[offset + 4];
        final Symbol LEFTBRAK = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRAK = _symbols[offset + 7];
        return new WhileStmt(a,b);
      }
    },
    new Action() { // [46] ifStmt =  IF LEFTPAR expr RIGHTPAR LEFTBRAK opt_stmt_list RIGHTBRAK
      public Symbol reduce(Symbol[] _symbols, int offset) {
        final Symbol IF = _symbols[offset + 1];
        final Symbol LEFTPAR = _symbols[offset + 2];
        final Expr a = (Expr) _symbols[offset + 3].value;
        final Symbol RIGHTPAR = _symbols[offset + 4];
        final Symbol LEFTBRAK = _symbols[offset + 5];
        final Block b = (Block) _symbols[offset + 6].value;
        final Symbol RIGHTBRAK = _symbols[offset + 7];
        return new IfStmt(a,b);
      }
    },
  };

  static final ParsingTables PARSING_TABLES = new ParsingTables(
    "U9pjMbjiL5KKNJFjTDhoA8zYWG9zKQ10AL3g0r4K1Imee2AAu0CLaSIeqHW$DC5ezCF4g9$" +
    "6HpH#QFprmsXYZ8c9NoG2jL0UyfA7L55440KzhdtldU7SkNFlp3cCrseuE#lii$VPw#vzph" +
    "czyofG$GhAaQ8Cnn1qOGQcOIbcmcr9LAC2PHYilaQc3P9EAJHZb3UILakCm7XCG0FgCH9Zq" +
    "8Hn69s9SbhQ5pNLYt9pTZBdT7Hmljtph7Igg0pCNnxmN97ZgSALWPYhFCzjzCoZFTSVeVx2" +
    "rLwLvG7kZPvd5JtdvrQhFtsHj$kiEtpMdPajKEVKEQ$NvzVuhBKIaTqrgBCvLTtbYxuR$kR" +
    "ikFh3isev2fxBlO4rhYE6#auhx4pNPt8ujVsEcf2u1n7Ir1br9cmkj0qpPiYUcRSwdQj#Ot" +
    "S96Z4sYg9EgzEcQTGfNKklJecKceE91Kjf2NWc5M2qvl5DBfWdqDIl8gwMtk$tIvOqnIAFp" +
    "RwrMUGvgMlfrKcHI9B$Vli5nTnlCTqxLljMXrdPyHpDFxk4UIubBekiedIrdT2rzEg4IAdp" +
    "24VzRCunpQD#2euADfiyntKjlJek4fL6$IWYshNyVbqqpWyYebtBx$Tcv#DQNACbMX1LHS7" +
    "Q9XLR6xfLl#fdJBzZBSpwhyFrk06BiGXBIh47LkTpJ4IqQ$dzkcYSxqL4kvRVhyi5rcQp1p" +
    "U5Noyqpr5TIw#EYaIIbfddmN9pYZg25SQSm#gmSQARZHd0BHQSMoqubi$HE3ZgaAwbLuT48" +
    "h8CwFLSvF04lnCHxLf#louQwPw86i9hSvl9Puo3kfPU7HI9v1pGjVJgW4Y1siptRR#8QDVo" +
    "#tNHIFT5Lf6$tMzEKVj4HBkMtw#Bnjah8jgr$7vTDCwt8g9To#$NHIkkM#rHUnYpnx4MefZ" +
    "MhNQhtUJiBfwZTec8TYs$tvlDVO$KhNQgdOpPQLHRd#eZfy#8iqFj86T7yHorNKIqQ$dztc" +
    "nmFRsgbp6z1dc#4H7jMdw$BXhfWMAkd9EdH$KOaooU8LRFdMswbbvj4udCio5oDdzxo9oYj" +
    "kfQUhLL99ApHTVIgoqY4V4fD7ao5lKO9zzpAQUXdTA1cPY1sSfhcEFqa5Xdb7Bw9g854z7A" +
    "Jm#JCGLjc8ffc9w9yZZveh8vqO16vrjNhGeaekRpUv0k43EBTcSE1sZsgan5SlKvv5mZmih" +
    "kGHdAsLUmniXer2brdXEeAk#rlMXdntckhjL4PiYv#DVerAQTLlYPPd9arXCUbx#vUs3MCD" +
    "gKaRap3Ja9dOjAeXg3C3YIOxCUcpmsd8g2bTG5F6bJHc5Etkiap$yriA$A#eUY1iCm72Cm4" +
    "hKOnMTuDgEisZYFpRxPh2UkCntG72IpOsqFCQHqUJ2ccFlwtwdDFe$yDPXpZFCWEohwwHZR" +
    "lcMV1uuLyJouG8xDlLFqiygijfBiWStvnBNNSTLcy$xW7tazBH77vZs55SUK4IF7yZaQ3yV" +
    "JCRmkNEJ4nB5vxbZTrvx#lxn$Y#jvRSE9wtMkX1oRzSIr1t7LDf3N4vd7vlFfGFx#m8PZim" +
    "TnVQut$gm9OEEpS3utdNM#yND$DP9Vu#K$2fyZtYG#8ZOJnu14WgWdkeYvn0RY1U8juXDY6" +
    "t4KI38koRWaOvBBY4U9vudtYC#8xSG9e6mGqKhC9rOIJn0l4#yJNn2xYDD0UGtHHYmWrXAF" +
    "4wyI7n9V4dk9Cq1g1D5EB2AM44yJZ4inBlKLiP$WMYj64Ht4Kc8ziObudU1QAxZMYYD0ccj" +
    "8SmrfhZMzdDX8S4$IRn0V4rk8Vg0oHKmWcebvnCF4YyGxnAT43t4SgAea65F5cAfLn6F4Iy" +
    "JR1FUageyu2LGF8He9xbtr6k99xupsRMAdWss$DZwOE#$vvJV3HBwvC32#DiTkrSPTdfR$k" +
    "LrChF3iTL7NPElNhl68GIqpYDN4KvxD#mZSDpn3l4QyItn0yFx3vnflipOEx9qDU1tvRw2m" +
    "kOrHlrtyPri79O6Pn6o#QZGHSnolw0JF9e7fa3CgmsIEwubfZY#1LiR8xz7jIDENn7Zw6eb" +
    "cOXpHG4noOXBe9DfuZGcqMr6E5c8iqK1V1iqU6hMnReydEec9I64ASqubklu6JmF7HW==");

  public LangParser() {
    super(PARSING_TABLES);
  }

  protected Symbol invokeReduceAction(int rule_num, int offset) {
    return actions[rule_num].reduce(_symbols, offset);
  }
}
